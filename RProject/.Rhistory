#plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), label_size = 12)
print("Step 2 complete!")
# the essentials ----
library(tidyverse)
library(edgeR)
library(matrixStats)
library(cowplot)
sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)
log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, # dataframe to be pivoted
cols = -1, # column names to be stored as a SINGLE variable
names_to = "samples", # name of that new variable (column)
values_to = "expression") # name of new variable (column) storing all the values (data)
p1 <- ggplot(log2.cpm.df.pivot) +
aes(x=samples, y=expression, fill=samples) +
geom_violin(trim = FALSE, show.legend = FALSE) +
stat_summary(fun = "median",
geom = "point",
shape = 95,
size = 10,
color = "black",
show.legend = FALSE) +
labs(y="log2 expression", x = "sample",
title="Log2 Counts per Million (CPM)",
subtitle="unfiltered, non-normalized",
caption=paste0("produced on ", Sys.time())) +
theme_bw()
cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=5 #user defined
myDGEList.filtered <- myDGEList[keepers,]
log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, # dataframe to be pivoted
cols = -1, # column names to be stored as a SINGLE variable
names_to = "samples", # name of that new variable (column)
values_to = "expression") # name of new variable (column) storing all the values (data)
p2 <- ggplot(log2.cpm.filtered.df.pivot) +
aes(x=samples, y=expression, fill=samples) +
geom_violin(trim = FALSE, show.legend = FALSE) +
stat_summary(fun = "median",
geom = "point",
shape = 95,
size = 10,
color = "black",
show.legend = FALSE) +
labs(y="log2 expression", x = "sample",
title="Log2 Counts per Million (CPM)",
subtitle="filtered, non-normalized",
caption=paste0("produced on ", Sys.time())) +
theme_bw()
myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, # dataframe to be pivoted
cols = -1, # column names to be stored as a SINGLE variable
names_to = "samples", # name of that new variable (column)
values_to = "expression") # name of new variable (column) storing all the values (data)
p3 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
aes(x=samples, y=expression, fill=samples) +
geom_violin(trim = FALSE, show.legend = FALSE) +
stat_summary(fun = "median",
geom = "point",
shape = 95,
size = 10,
color = "black",
show.legend = FALSE) +
labs(y="log2 expression", x = "sample",
title="Log2 Counts per Million (CPM)",
subtitle="filtered, TMM normalized",
caption=paste0("produced on ", Sys.time())) +
theme_bw()
plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), label_size = 12)
beep(sound = 2)
# Load packages ------
library(tidyverse) # you're familiar with this fromt the past two lectures
library(DT) # for making interactive tables
library(plotly) # for making interactive plots
library(gt) # A layered 'grammar of tables' - think ggplot, but for tables
# Identify variables of interest in study design file ----
targets
group <- targets$group
group <- factor(group)
# Prepare your data -------
# for this part of the class you'll use your normalized and filtered data in log2 cpm
# make sure you have this object already in your work environment
# if you don't, go back to the Step2 script and generate it
log2.cpm.filtered.norm.df
# Hierarchical clustering ---------------
#hierarchical clustering can only work on a data matrix, not a data frame
#try using filtered and unfiltered data...how does this change the result?
#try other distance methods (e.g. switch from 'maximum' to 'euclidean')...how does this change the result?
distance <- dist(t(log2.cpm.filtered.norm), method = "maximum") #other distance methods are "euclidean", maximum", "manhattan", "canberra", "binary" or "minkowski"
clusters <- hclust(distance, method = "average") #other agglomeration methods are "ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", or "centroid"
plot(clusters, labels=sampleLabels)
png('ClusterDendrogram.png')
plot(clusters, labels=sampleLabels)
dev.off()
png('ClusterDendrogram.png')
plot(clusters, labels=sampleLabels)
dev.off()
# Principal component analysis (PCA) -------------
pca.res <- prcomp(t(log2.cpm.filtered.norm), scale.=F, retx=T)
#look at the PCA result (pca.res) that you just created
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
pca.res$rotation #$rotation shows you how much each gene influenced each PC (called 'scores')
pca.res$x # 'x' shows you how much each sample influenced each PC (called 'loadings')
#note that these have a magnitude and a direction (this is the basis for making a PCA plot)
screeplot(pca.res) # A screeplot is a standard way to view eigenvalues for each PCA
pc.var<-pca.res$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) # we can then use these eigenvalues to calculate the percentage variance explained by each PC
pc.per
# Visualize your PCA result ------------------
#lets first plot any two PCs against each other
#We know how much each sample contributes to each PC (loadings), so let's plot
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
aes(x=PC1, y=PC2, label=sampleLabels) +
geom_point(size=4) +
# geom_label() +
# stat_ellipse() +
xlab(paste0("PC1 (",pc.per[1],"%",")")) +
ylab(paste0("PC2 (",pc.per[2],"%",")")) +
labs(title="PCA plot",
caption=paste0("produced on ", Sys.time())) +
# coord_fixed() +
theme_bw()
ggsave("PCA.png", width = 7, height = 7)
dev.off()
pc.per
# Create a PCA 'small multiples' chart ----
# this is another way to view PCA laodings to understand impact of each sample on each pricipal component
pca.res.df <- pca.res$x[,1:4] %>% # note that this is the first time you've seen the 'pipe' operator from the magrittr package
as_tibble() %>%
add_column(sample = sampleLabels,
group = group)
pca.pivot <- pivot_longer(pca.res.df, # dataframe to be pivoted
cols = PC1:PC4, # column names to be stored as a SINGLE variable
names_to = "PC", # name of that new variable (column)
values_to = "loadings") # name of new variable (column) storing all the values (data)
ggplot(pca.pivot) +
aes(x=sample, y=loadings, fill=group) + # you could iteratively 'paint' different covariates onto this plot using the 'fill' aes
geom_bar(stat="identity") +
facet_wrap(~PC) +
labs(title="PCA 'small multiples' plot",
caption=paste0("produced on ", Sys.time())) +
theme_bw() +
coord_flip()
ggsave("PCA_bar.png", width = 7, height = 7)
dev.off()
# Use dplyr 'verbs' to modify our dataframe ----
# use dplyr 'mutate' function to add new columns based on existing data
mydata.df <- log2.cpm.filtered.norm.df %>%
mutate(healthy.AVG = (HS01 + HS02 + HS03 + HS04 + HS05)/5,
disease.AVG = (CL08 + CL10 + CL11 + CL12 + CL13)/5,
#now make columns comparing each of the averages above that you're interested in
LogFC = (disease.AVG - healthy.AVG)) %>%
mutate_if(is.numeric, round, 2)
#now look at this modified data table
mydata.df
# Use dplyr 'arrange' and 'select' to sort your dataframe based on any variable
# first, we'll use dplyr "arrange" function to sort rows based on the values in a column of interest
# then we'll display 'select' only the columns we're interested in seeing
mydata.sort <- mydata.df %>%
dplyr::arrange(desc(LogFC)) %>%
dplyr::select(geneID, LogFC)
# Use dplyr "filter" and "select" functions to pick out genes of interest
# ways to tweak the 'select' function:
# use ':' between two column names to select all columns between
# use 'contains', 'starts_with' or 'ends_with' to modify how you select
# can refer to columns using exact name or numerical indicator
# use boolean operators such as '&' (and), '|' (or), '==' (equal to), '!' (not)
mydata.filter <- mydata.df %>%
dplyr::filter(geneID=="MMP1" | geneID=="GZMB" | geneID=="IL1B" | geneID=="GNLY" | geneID=="IFNG"
| geneID=="CCL4" | geneID=="PRF1" | geneID=="APOBEC3A" | geneID=="UNC13A" ) %>%
dplyr::select(geneID, healthy.AVG, disease.AVG, LogFC) %>%
dplyr::arrange(desc(LogFC))
# you can also filter based on any regular expression
mydata.grep <- mydata.df %>%
dplyr::filter(grepl('CXCL|IFI', geneID)) %>%
dplyr::select(geneID, healthy.AVG, disease.AVG, LogFC) %>%
dplyr::arrange(desc(geneID))
# Produce publication-quality tables using the gt package ----
gt(mydata.filter)
# now with a few more options
mydata.filter %>%
gt() %>%
fmt_number(columns=2:4, decimals = 1) %>%
tab_header(title = md("**Regulators of skin pathogenesis**"),
subtitle = md("*during cutaneous leishmaniasis*")) %>%
tab_footnote(
footnote = "Deletion or blockaid ameliorates disease in mice",
locations = cells_body(
columns = geneID,
rows = c(6, 7))) %>%
tab_footnote(
footnote = "Associated with treatment failure in multiple studies",
locations = cells_body(
columns = geneID,
rows = c(2:9))) %>%
tab_footnote(
footnote = "Implicated in parasite control",
locations = cells_body(
columns = geneID,
rows = c(2))) %>%
tab_source_note(
source_note = md("Reference: Amorim *et al*., (2019). DOI: 10.1126/scitranslmed.aar3619"))
# Make an interactive table using the DT package ----
datatable(mydata.df[,c(1,12:14)],
extensions = c('KeyTable', "FixedHeader"),
filter = 'top',
options = list(keys = TRUE,
searchHighlight = TRUE,
pageLength = 10,
lengthMenu = c("10", "25", "50", "100")))
# Make an interactive scatter plot with plotly -----
# begin by storing your ggplot object
myplot <- ggplot(mydata.df) +
aes(x=healthy.AVG, y=disease.AVG) +
geom_point(shape=16, size=1) +
ggtitle("disease vs. healthy") +
theme_bw()
#now use the ggplotly function from the plotly package to convert this ggplot object into an interactive plot
ggplotly(myplot)
ggsave("disease_v_healthy_scatter.png", width = 7, height = 7)
dev.off()
dev.off()
# Produce publication-quality tables using the gt package ----
gt(mydata.filter)
# now with a few more options
mydata.filter %>%
gt() %>%
fmt_number(columns=2:4, decimals = 1) %>%
tab_header(title = md("**Regulators of skin pathogenesis**"),
subtitle = md("*during cutaneous leishmaniasis*")) %>%
tab_footnote(
footnote = "Deletion or blockaid ameliorates disease in mice",
locations = cells_body(
columns = geneID,
rows = c(6, 7))) %>%
tab_footnote(
footnote = "Associated with treatment failure in multiple studies",
locations = cells_body(
columns = geneID,
rows = c(2:9))) %>%
tab_footnote(
footnote = "Implicated in parasite control",
locations = cells_body(
columns = geneID,
rows = c(2))) %>%
tab_source_note(
source_note = md("Reference: Amorim *et al*., (2019). DOI: 10.1126/scitranslmed.aar3619"))
# Make an interactive table using the DT package ----
datatable(mydata.df[,c(1,12:14)],
extensions = c('KeyTable', "FixedHeader"),
filter = 'top',
options = list(keys = TRUE,
searchHighlight = TRUE,
pageLength = 10,
lengthMenu = c("10", "25", "50", "100")))
# Make an interactive table using the DT package ----
datatable(mydata.df[,c(1,12:14)],
extensions = c('KeyTable', "FixedHeader"),
filter = 'top',
options = list(keys = TRUE,
searchHighlight = TRUE,
pageLength = 10,
lengthMenu = c("10", "25", "50", "100")))
# Make an interactive scatter plot with plotly -----
# begin by storing your ggplot object
myplot <- ggplot(mydata.df) +
aes(x=healthy.AVG, y=disease.AVG) +
geom_point(shape=16, size=1) +
ggtitle("disease vs. healthy") +
theme_bw()
#now use the ggplotly function from the plotly package to convert this ggplot object into an interactive plot
ggplotly(myplot)
ggsave("disease_v_healthy_scatter.png", width = 7, height = 7)
#let's customize this graphic by adding a more informative mouseover tooltip
myplot <- ggplot(mydata.df) +
aes(x=healthy.AVG, y=disease.AVG,
text = paste("Symbol:", geneID)) +
geom_point(shape=16, size=1) +
ggtitle("disease vs. healthy") +
theme_bw()
ggplotly(myplot)
ggsave("disease_v_healthy_scatter_inter.png", width = 7, height = 7)
# Load packages ------
# nothing new here...you should already have all these packages in your R package library
library(tidyverse)
library(rhdf5)
library(edgeR)
archs4.mouse <- "mouse_gene_v2.3.h5"
h5ls(archs4.mouse)
archs4.mouse <- "archs4_gene_mouse_v2.1.2.h5"
h5ls(archs4.mouse)
# data for 53,511 MOUSE genes across 932,405 samples
all.samples.mouse <- h5read(archs4.mouse, name="meta/samples/geo_accession")
dim(all.samples.mouse)
# query ARCHS4 database ----
# choose your samples based on GEO or SRA ID
mySamples <- c("GSM2310941", # WT_unstim_rep1
"GSM2310942", # WT_unstim_rep2
"GSM2310943", # Ripk3_unstim_rep1
"GSM2310944", # Ripk3_unstim_rep2
"GSM2310945", # Ripk3Casp8_unstim_rep1
"GSM2310946", # Ripk3Casp8_unstim_rep2
"GSM2310947", # WT_LPS.6hr_rep1
"GSM2310948", # WT_LPS.6hr_rep2
"GSM2310949", # Ripk3_LPS.6hr_rep1
"GSM2310950", # Ripk3_LPS.6hr_rep2
"GSM2310951", # Ripk3Casp8_LPS.6hr_rep1
"GSM2310952") # Ripk3Casp8_LPS.6hr_rep2
# query ARCHS4 database ----
# choose your samples based on GEO or SRA ID
mySamples <- c("GSM2310941", # WT_unstim_rep1
"GSM2310942", # WT_unstim_rep2
"GSM2310943", # Ripk3_unstim_rep1
"GSM2310944", # Ripk3_unstim_rep2
"GSM2310945", # Ripk3Casp8_unstim_rep1
"GSM2310946", # Ripk3Casp8_unstim_rep2
"GSM2310947", # WT_LPS.6hr_rep1
"GSM2310948", # WT_LPS.6hr_rep2
"GSM2310949", # Ripk3_LPS.6hr_rep1
"GSM2310950", # Ripk3_LPS.6hr_rep2
"GSM2310951", # Ripk3Casp8_LPS.6hr_rep1
"GSM2310952") # Ripk3Casp8_LPS.6hr_rep2
# Identify columns to be extracted from ARCHS4 database
my.sample.locations <- which(all.samples.mouse %in% mySamples) # first time you've seen the %in% operator.
# extract gene symbols from the metadata
genes <- h5read(archs4.mouse, "meta/genes/symbol")
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(my.sample.locations, 1:length(genes)))
# transpose to get genes as rows and samples as columns
expression <- t(expression)
rownames(expression) <- genes
colnames(expression) <- all.samples.mouse[my.sample.locations]
colSums(expression) #this shows the sequencing depth for each of the samples you've extracted
archs4.dgelist <- DGEList(expression)
archs4.cpm <- cpm(archs4.dgelist)
colSums(archs4.cpm)
# Filter and normalize the extracted data ----
table(rowSums(archs4.dgelist$counts==0)==12)
keepers <- rowSums(archs4.cpm>1)>=2
archs4.dgelist.filtered <- archs4.dgelist[keepers,]
dim(archs4.dgelist.filtered)
archs4.dgelist.filtered.norm <- calcNormFactors(archs4.dgelist.filtered, method = "TMM")
archs4.filtered.norm.log2.cpm <- cpm(archs4.dgelist.filtered.norm, log=TRUE)
# Extract sample metadata from ARCHS4 to create a study design file ----
# extract the sample source
sample_source_name <- h5read(archs4.mouse, "meta/samples/source_name_ch1")
# extract sample title
sample_title <- h5read(archs4.mouse, name="meta/samples/title")
# extract sample characteristics
sample_characteristics<- h5read(archs4.mouse, name="meta/samples/characteristics_ch1")
# let's try putting this all together in a study design file
studyDesign <- tibble(Sample_title = sample_title[my.sample.locations],
Sample_source = sample_source_name[my.sample.locations],
Sample_characteristics = sample_characteristics[my.sample.locations])
#based on what we extracted from ARCHS4 above, lets customize and clean-up this study design file
studyDesign <- tibble(Sample_title = sample_title[my.sample.locations],
genotype = c("WT", "WT", "Ripk3", "Ripk3", "Ripk3Casp8", "Ripk3Casp8", "WT", "WT", "Ripk3", "Ripk3", "Ripk3Casp8", "Ripk3Casp8"),
treatment = c("unstim", "unstim", "unstim", "unstim", "unstim", "unstim", "LPS", "LPS", "LPS", "LPS", "LPS", "LPS"))
#capture experimental variables as factors from this study design
genotype <- factor(studyDesign$genotype)
treatment <- factor(studyDesign$treatment)
sampleName <- studyDesign$Sample_title
# Principal component analysis (PCA) -------------
pca.res <- prcomp(t(archs4.filtered.norm.log2.cpm), scale.=F, retx=T)
#look at pca.res in environment
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
pca.res$rotation #$rotation shows you how much each gene influenced each PC (called 'scores')
pca.res$x #$x shows you how much each sample influenced each PC (called 'loadings')
#note that these loadings have a magnitude and a direction (this is the basis for making a PCA plot)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
# Visualize your PCA result ------------------
#lets first plot any two PCs against each other
#We know how much each sample contributes to each PC (loadings), so let's plot
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
aes(x=PC1, y=PC2) +
geom_point(size=4) +
# geom_label() +
# stat_ellipse() +
xlab(paste0("PC1 (",pc.per[1],"%",")")) +
ylab(paste0("PC2 (",pc.per[2],"%",")")) +
labs(title="PCA plot",
caption=paste0("produced on ", Sys.time())) +
coord_fixed() +
theme_bw()
#look at pca.res in environment
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
pca.res$rotation #$rotation shows you how much each gene influenced each PC (called 'scores')
pca.res$x #$x shows you how much each sample influenced each PC (called 'loadings')
#note that these loadings have a magnitude and a direction (this is the basis for making a PCA plot)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
#note that these loadings have a magnitude and a direction (this is the basis for making a PCA plot)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
genotype
treatment
sampleName
# Principal component analysis (PCA) -------------
pca.res <- prcomp(t(archs4.filtered.norm.log2.cpm), scale.=F, retx=T)
pca.res
#look at pca.res in environment
ls(pca.res)
expression
archs4.dgelist
keepers
# Filter and normalize the extracted data ----
table(rowSums(archs4.dgelist$counts==0)==12)
keepers <- rowSums(archs4.cpm>1)>=2
keepers
archs4.dgelist.filtered
dim(archs4.dgelist.filtered)
dim(archs4.dgelist.filtered)
dim(archs4.dgelist.filtered)
archs4.dgelist.filtered.norm <- calcNormFactors(archs4.dgelist.filtered, method = "TMM")
archs4.dgelist.filtered.norm
archs4.dgelist.filtered.norm <- calcNormFactors(archs4.dgelist.filtered, method = "TMM")
archs4.dgelist.filtered.norm
dim(archs4.dgelist.filtered)
# extract gene symbols from the metadata
genes <- h5read(archs4.mouse, "meta/genes")
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(my.sample.locations, 1:length(genes)))
# transpose to get genes as rows and samples as columns
expression <- t(expression)
rownames(expression) <- genes
colnames(expression) <- all.samples.mouse[my.sample.locations]
colSums(expression) #this shows the sequencing depth for each of the samples you've extracted
archs4.dgelist <- DGEList(expression)
archs4.cpm <- cpm(archs4.dgelist)
colSums(archs4.cpm)
# Filter and normalize the extracted data ----
table(rowSums(archs4.dgelist$counts==0)==12)
keepers <- rowSums(archs4.cpm>1)>=2
archs4.dgelist.filtered <- archs4.dgelist[keepers,]
dim(archs4.dgelist.filtered)
archs4.dgelist.filtered.norm <- calcNormFactors(archs4.dgelist.filtered, method = "TMM")
archs4.filtered.norm.log2.cpm <- cpm(archs4.dgelist.filtered.norm, log=TRUE)
dim(archs4.dgelist.filtered)
# query ARCHS4 database ----
# choose your samples based on GEO or SRA ID
mySamples <- c("GSM2310941", # WT_unstim_rep1
"GSM2310942", # WT_unstim_rep2
"GSM2310943", # Ripk3_unstim_rep1
"GSM2310944", # Ripk3_unstim_rep2
"GSM2310945", # Ripk3Casp8_unstim_rep1
"GSM2310946", # Ripk3Casp8_unstim_rep2
"GSM2310947", # WT_LPS.6hr_rep1
"GSM2310948", # WT_LPS.6hr_rep2
"GSM2310949", # Ripk3_LPS.6hr_rep1
"GSM2310950", # Ripk3_LPS.6hr_rep2
"GSM2310951", # Ripk3Casp8_LPS.6hr_rep1
"GSM2310952") # Ripk3Casp8_LPS.6hr_rep2
# Identify columns to be extracted from ARCHS4 database
my.sample.locations <- which(all.samples.mouse %in% mySamples) # first time you've seen the %in% operator.
# extract gene symbols from the metadata
genes <- h5read(archs4.mouse, "meta/genes")
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(my.sample.locations, 1:length(genes)))
rownames(expression) <- genes
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(1:length(genes), my.sample.locations,))
# extract gene symbols from the metadata
genes <- h5read(archs4.mouse, "meta/genes")
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(1:length(genes), my.sample.locations,))
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(1:length(genes), my.sample.locations))
# extract gene symbols from the metadata
genes <- h5read(archs4.mouse, "meta/genes")
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(1:length(genes), my.sample.locations))
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(my.sample.locations, 1:length(genes)))
# transpose to get genes as rows and samples as columns
expression <- t(expression)
rownames(expression) <- genes
colnames(expression) <- all.samples.mouse[my.sample.locations]
colSums(expression) #this shows the sequencing depth for each of the samples you've extracted
expression
colSums(expression) #this shows the sequencing depth for each of the samples you've extracted
archs4.dgelist <- DGEList(expression)
archs4.cpm <- cpm(archs4.dgelist)
colSums(archs4.cpm)
# Filter and normalize the extracted data ----
table(rowSums(archs4.dgelist$counts==0)==12)
keepers <- rowSums(archs4.cpm>1)>=2
archs4.dgelist.filtered <- archs4.dgelist[keepers,]
# data for 53,511 MOUSE genes across 932,405 samples
all.samples.mouse <- h5read(archs4.mouse, name="meta/samples/geo_accession")
